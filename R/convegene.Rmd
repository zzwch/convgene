---
title: "Convegene"
author: "Hazard"
date: "2020/4/16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = F)
rm(list = ls())
```

# convegene
This package is designed to conveniently convert gene between human and mouse.
Hope it may be valuable for researcher/bioinformatican on analyses of human/mouse data.

## functions
some functions
Here I get a stirng of genes from a literature,
`Cdh5 Ptprc Unc5b CD14 CD15 CD33`
I want to check their expression in my dataset.
first, I need to split the string into a vector of gene symbols.    
second, I may check the official gene symbol for some of them.   
third, I want to check their homologous genes in human.   

I also want to get all the gene IDs commonly used for my selected genes.   
Or even export a html for external searching in web browser.   

So I write down some functions to realize this routinely need in my work.   
str_to_gene(): split a string into a vector of genes
alias_to_official(): map alias to official symbols or IDs
gene_to_homo(): get homologous genes for the input genes
all_to_html(): export the gene tables into a local searchable html

### alias_to_official()
```{r}
library(org.Hs.eg.db)
library(org.Mm.eg.db)

```


### str_to_gene()
```{r}
#' convert string vector to list/vector of genes
#'
#' @param x a string with multiple gene symbols seperated by non-numeric/letter/hyphen (Depends on REGEX parameter below); numeric/letter/hyphen charactor will be treated as parts of gene symbols. A vector of strings is also supported, in which case you can choose to return list. If missing of x, the string will be read from system clipboard automately (I like it!).
#' @param to_clipboard If `False` return a charactor vector of gene symbols (default), if `TRUE` return value to clipboard
#' @param as_list If `FALSE` (default) return value is a vector. If `TRUE` reutrn value is structured in list, this is useful when `to_clipboard=T` so that you can paste the return (symbols with quoted) to python.
#' @param print print the return or not. (default: FALSE)
#' @param REGEX a regular expression used for identifying chars of gene symbols. Default setting should work in most cases. You can also customize it yourself.
#'
#' @return A charactor vector of gene symbols or A list of vectors (with names if x named) in case of as_list=T
#' @export
#'
#' @examples
#' # you can copy some text from anywhere (a research article for example) and then str_to_gene() will help to parse it into gene vector.
#' str_to_gene()
#' # custom string of genes
#' str_to_gene(x = "Runx1, Gata4 Gata1;, Dll4, Nkx2-5, NOTAGENE") # note: the function does not check validity of gene symbols
#' str_to_gene(x = c(Hematopoietic ="Runx1 Gata4 GATA1", Ery = "Gypa Gype Ptprc", Endothelial = "Pecam1 Cdh5"), as_list = T)
str_to_gene <- function(x, to_clipboard = F, as_list = F, print = F, REGEX = "[^a-zA-Z0-9\\-\\.]"){
  if(missing(x)) {
    if(clipr::clipr_available()){
      x <- clipr::read_clip()
    }else{
      stop("system clipboard is not available")
    }
  }
  geneList <-
    stringr::str_split( # split by space
      stringr::str_squish( # squish multiple sapces into one space
        stringr::str_replace_all( # replace all non-symbol-charactor with a space
          x, REGEX, " ")
        ), " ")
  names(geneList) <- names(x) # set names if available
  if(!as_list) {
    geneList <- unlist(geneList)
    if(anyDuplicated(geneList)){
      message("returned gene list is redundant! you may use unique() to deduplicate it.")
    }
  }else{
    dup_ind <- which(sapply(geneList, anyDuplicated) > 0)
    if(length(dup_ind)>0){
      dup_ind <- paste(dup_ind, collapse = ', ')
      message(stringr::str_glue("There are duplicated genes in list of index {dup_ind}"))
    }
  }
  if(print) print(geneList)
  if(to_clipboard) suppressWarnings(clipr::write_clip(geneList)) else return(geneList)
}

```

### str_to_char()
```{r}
#' convert string into a vector of each char
#'
#' @param x a string or a vector of strings. Note if a vector supplied, it will be collapsed. If you wanna multiple vectors of char returned, you can use sapply() to wrapper the function.
#' @param unique If `TRUE` chars should be uniqued, otherwise as it is.
#' @param sort If `TRUE` chars should be sorted by alphabetic, otherwise as it is.
#' @param ... more parameters to be used in sort(). such as order decreasing = T if you like.
#'
#' @return a vector of chars
#' @export
#'
#' @examples
#' str_to_char(x = c("Here it is"), unique = F, sort = F)
#' str_to_char(x = c("Yes", "or", "Not"), unique = F, sort = F)
#' sapply(c("Yes", "or", "Not"), str_to_char, sort = F, unique = F)
str_to_char <- function(x, unique = F, sort = F, ...){
  chars <- stringr::str_split(
    stringr::str_flatten(unlist(x)),
    "", simplify = F)[[1]]
  if(unique) chars <- unique(chars)
  if(sort) chars <- sort(chars, ...)
  return(chars)
}

```



### insertVector
```{r}

# vector insertion
insertVector <- function(x, index, value){
  # insert value after index of x
  # if index == 0, value will be insert at the begin of x
  # negative index is also supported
  # index larger than length of x will be warned, but allowed with NAs filled in x.
  if(any(duplicated(index))) stop("index is duplicated")
  index[index < 0] <- length(x)+1+index[index < 0] # in case of negative index
  if(any(duplicated(index))) stop("index is duplicated, beware of negative index")
  if(any(index < 0)) stop("beware of negative index")

  index_ord <- order(index)
  value <- value[seq_along(index)]

  index <- index[index_ord]
  value <- value[index_ord]

  if(index[length(index)] > length(x)) {
    warning("max index is larger than length of x, NA will be introduced")
    x <- c(x, rep(NA, index[length(index)] - length(x)))
  }

  ret <- unlist(lapply(seq_along(index), function(i){
    if(index[i] == 0) return(value[[i]])
    start_ind <- ifelse(i == 1, 0, index[[i-1]]) + 1
    end_ind <- index[[i]]
    return(c(x[start_ind:end_ind], value[[i]]))
  }))

  if(index[length(index)] < length(x)) ret <- c(ret, x[(index[length(index)]+1):length(x)])

  return(ret)
}
```

