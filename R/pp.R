#' Scale data in each group
#'
#' @param data expression matrix of feature by cell, usually normalized (in log scale) but not feature scaled.
#' @param group_by a vector including cell annotations
#' @param by_log calculate in log scale or in normalized scale; If TRUE log_base will be ignored.
#' @param log_base base::exp(1) or 2 or other else, depends on your normalization method.
#' @param center a logical value used in base::scale
#' @param scale a logical value used in base::scale
#'
#' @return scaled data
#' @export
#'
#' @examples
#'
pp_centerData <- function(
  data,
  group_by = NULL,
  by_log = F,
  log_base = base::exp(1),
  center = T,
  scale = T){

  if(!by_log) data <- log_base^data
  data <- as.matrix(data)

  if(IsNULLorNA(group_by)) group_by <- rep("A", ncol(data))

  if(is.factor(group_by)){
    group_by <- droplevels(group_by)
  }else{
    group_by <- factor(group_by)
  }

  for(i in levels(group_by)){
    data[,group_by == i] <- t(base::scale(t(data[,group_by == i]), center = center, scale = scale))
  }

  return(data)
}


#' A Wrapper of harmony::RunHarmony
#'
#' RunHarmony did not support dims.use actually, so I wrote this wrapper function to support that.
#'
#' @param object Seurat object
#' @param dims.use Which PCA dimensions to use for Harmony. By default, use all
#' @param group.by.vars Which variable(s) to remove (character vector).
#' @param ... other parameters to be used in harmony::HarmonyMatrix
#'
#' @return Seurat (version 3) object.
#' @export
#'
#' @examples
#'
pp_runHarmony <- function(object, dims.use, group.by.vars,...){
  embedding <- Seurat::Embeddings(object)[,dims.use]
  harmonyEmbed <- harmony::HarmonyMatrix(embedding, object@meta.data, group.by.vars,
                                FALSE, 0, ...)
  rownames(harmonyEmbed) <- row.names(embedding)
  colnames(harmonyEmbed) <- paste0("harmony_", seq_len(ncol(harmonyEmbed)))
  suppressWarnings({
    harmonydata <- Seurat::CreateDimReducObject(embeddings = harmonyEmbed,
                                                stdev = as.numeric(apply(harmonyEmbed, 2, stats::sd)), key = "harmony")
  })
  object[["harmony"]] <- harmonydata
  if (FALSE) {
    object <- Seurat::ProjectDim(object, reduction = "harmony",
                                 overwrite = TRUE, verbose = FALSE)
  }
  return(object)
}

#' Find variable features across batches
#'
#' Identifies Highly variable features (HVFs) for each batch, then combine them into a single vector of HVFs by count.
#'
#' @param object Seurat object
#' @param split_by a colname of meta.data
#' @param groups only some groups of split_by are considered.
#' @param nfeatures Number of features to select as top variable features; only used when selection.method is set to 'dispersion' or 'vst'
#' @param ... Arguments passed to Seurat::FindVariableFeatures
#'
#' @return A vector of variable features
#' @export
#'
#' @examples
#'
pp_findVariableFeatures <- function(object, split_by = "ident", groups = NULL, nfeatures = 2000, assay = "RNA", log_var = F, ...){
  object_list <- Seurat::SplitObject(object, split_by)
  if(!is.null(groups)) object_list <- object_list[groups]
  hvgs <- data.frame(row.names = rownames(object))
  for (i in seq_along(object_list)) {
    object_list[[i]] <- Seurat::FindVariableFeatures(object_list[[i]], nfeatures = nfeatures, assay = assay,...)
    var_data <- object_list[[i]]@assays[[assay]]@meta.features
    var_ind <- grep("variance", colnames(var_data), value = T, ignore.case = T)
    hvgs <- cbind(hvgs, var_data[,var_ind[length(var_ind)]])
  }
  if(log_var){
    names(sort(rowMeans(log(hvgs)), decreasing = T)[1:nfeatures])
  }else{
    names(sort(rowMeans(hvgs), decreasing = T)[1:nfeatures])
  }
}


#' render rmarkdown file for de-multiplex hash-tag data of h5file generated by cellranger
#'
#' @param h5file .h5 file generated by cellranger
#' @param seuratfile save seurat obejct into this file, eg. 'hashtag.seurat.Rdata'
#' @param hashtag hash-tag names used in the feature-ref file of your cellranger pipeline
#' @param sample real sample names represented by hash-tag, must be corresponding to hashtag each by each.
#' @inheritParams rmarkdown::render
#'
#' @details
#' Given that this package is designed for human, mouse and macaca,
#' when Mitochondria genes did not start with "mt-" (case was ignored. This situation should only occur in Macaca),
#' Ensembl gene id (already stored in this package) of Macaca mulatta will be used.
#'
#' @seealso \code{\link{rmarkdown::render}}
#'
#' @return derived html file
#' @export
#'
#' @examples
#'
pp_hashtagDemultiplex <- function(
  h5file,
  seuratfile,
  sample,
  hashtag = stringr::str_glue("B025{1:6}_anti-human_Hashtag_{1:6}"),
  output_format = "html_document",
  output_file = NULL,
  output_dir = "./") {

  rmdfile <- system.file("rmd", "hashtag_demux.Rmd", package = "convgene")
  rmarkdown::render(rmdfile, output_format = output_format, output_file = output_file, output_dir = output_dir,
                    knit_root_dir = getwd(),
                    params = list(
                      h5file = h5file,
                      seuratfile = seuratfile,
                      sample = sample,
                      hashtag = hashtag
                    ))
}

#' Annotate seurat data derived by pp_hashtagDemultiplex function
#'
#' @param files seurat Rdata files produced by pp_hashtagDemultiplex
#' @param metadata annotation information for each file/seurat_object.
#' e.g. list(c(Batch = "b1"), c(Batch = "b2"), NULL, c(Batch = "b4"))
#'
#' @return a list of seurat objects
#' @export
#'
#' @examples
#'
pp_annotateHashtagSeurat <- function(files, metadata = NULL){
  message("Be carefull the correspondence between files and metadata!")
  if(!is.null(metadata) && length(files) != length(metadata)){
    stop("metadata should be NULL, or with equal length of files!")
  }
  lapply(seq_along(files), function(i){
    seurat_obj <- load(files[i])
    seurat_obj <- get(seurat_obj)
    if(!is.null(metadata[[i]])){
      for(x in metadata[i]){
        seurat_obj[[names(x)]] <- x
      }
    }
    return(seurat_obj)
  })
}


#' Remove ccgenes generated by cor analysis (cor > 0.3) from hvgs.
#'
#' @param object seurat object
#' @param features set NULL to use VariableFeatures
#' @param cor_th threshold above which presumed to be cc genes.
#'
#' @return seurat object
#' @export
#'
#' @examples
#'
pp_removeCCgenesByCor <- function(object, features = NULL, cor_th = 0.3){
  if(is.null(features)) features <- VariableFeatures(object)
  object_cc_cor <- apply(GetAssayData(object)[features,], 1,
                         function(x){
                           max(abs(cor(x, object$S.Score)),
                               abs(cor(x, object$G2M.Score)))
                         }
  )
  VariableFeatures(object) <- setdiff(features, names(which(object_cc_cor > cor_th)))
  return(object)
}

#' A wrapper function to quickly run standard processing pipeline
#'
#' Run NormalizeData, CellCycleScoring, FindVariableFeatures, ScaleData, RunUMAP/TSNE and FindClusters.
#'
#' @param object a Seurat object
#' @param scale.factor Sets the scale factor for cell-level normalization. (NormalizeData)
#' @param s.features A vector of features associated with S phase (CellCycleScoring)
#' @param g2m.features A vector of features associated with G2M phase (CellCycleScoring)
#' @param do.regress.cc regress out cell cycle scores (ScaleData)
#' @param vars.to.regress other vars to be regressed
#' @param do.scale Whether to scale the data. (ScaleData)
#' @param pp do SCTransform or standard RNA process
#' @param center_by set a meta name when pp == "centerData" (pp_centerData)
#' @param nfeatures Number of features to return (SCTransform/FindVariableFeatures)
#' @param remove_ccgenes_by_cor Only used in RNA or centerData pipeline. Remove ccgenes generated by cor analysis (cor > 0.3) from hvgs.
#' @param ndim Number of dimensions to use for dimensionality reduction and clustering (RunUMAP/TSNE/FindClusters)
#' @param skip_tsne you may set TRUE to skip RunTSNE step for large dataset.
#' @param resolution Value of the resolution parameter (FindClusters)
#'
#' @return a Seurat object
#' @export
#'
#' @examples
#'
pp_preprocess <- function(object,
                          scale.factor = 1e4,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.gene,
                          do.regress.cc = T,
                          vars.to.regress = NULL,
                          do.scale = T,
                          pp = c("SCT", "RNA", "centerData"),
                          center_by = NULL,
                          nfeatures = 2000,
                          remove_ccgenes_by_cor = F,
                          ndim = 20,
                          skip_tsne = F,
                          resolution = 0.5){
  DefaultAssay(object) <- "RNA"
  object %<>% NormalizeData(scale.factor = scale.factor) %>%
    CellCycleScoring(s.features = s.features, g2m.features = g2m.features, set.ident = T)

  vars.to.regress <- if(do.regress.cc) unique(c(vars.to.regress, "S.Score", "G2M.Score")) else vars.to.regress

  if(pp == "SCT"){
    object %<>% SCTransform(variable.features.n = nfeatures, vars.to.regress = vars.to.regress) %>%
      CellCycleScoring(s.features = s.features, g2m.features = g2m.features, set.ident = T)
  }else if(pp == "RNA") {
    object %<>% FindVariableFeatures(nfeatures = nfeatures)  %>%
      CellCycleScoring(s.features = s.features, g2m.features = g2m.features, set.ident = T)
    if(remove_ccgenes_by_cor) object %<>% pp_removeCCgenesByCor()
    object %<>%
      ScaleData(vars.to.regress = vars.to.regress, do.scale = do.scale)
  }else if(pp == "centerData"){
    object %<>% FindVariableFeatures(nfeatures = nfeatures)

    object_data <- GetAssayData(object)
    object_data_centered <- pp_centerData(object_data, group_by = object[[center_by]][[center_by]], by_log = T, scale = F)
    object@assays$RNA@data <- object_data_centered

    object %<>% CellCycleScoring(s.features = s.features, g2m.features = g2m.features, set.ident = T)
    if(remove_ccgenes_by_cor) object %<>% pp_removeCCgenesByCor()
    object %<>%
      ScaleData(vars.to.regress = vars.to.regress, do.scale = do.scale)

    object@assays$RNA@data <- object_data
  }

  object %<>% RunPCA(npcs = ndim)

  object %<>% RunUMAP(dims = 1:ndim)
  if(!skip_tsne) object %<>% RunTSNE(dims = 1:ndim)
  object %<>% FindNeighbors(dims = 1:ndim) %>% FindClusters(resolution = resolution)
  return(object)
}



#' A wrapper function to quickly run fastMNN using SeuratWrappers::RunFastMNN
#'
#' Run NormalizeData, CellCycleScoring, SelectIntegrationFeatures, RunFastMNN, RunUMAP/TSNE, FindClusters and FindMarkers.
#' And save object_mnn and object_degs to xls and Rdata files.
#'
#' @param object_list a list of Seurat objects
#' @param genes_used Set NULL to use the intersection of all Seurat objects.
#' @param batch_by Attribute for splitting. Default is "Batch". (SplitObject)
#' @param scale.factor Sets the scale factor for cell-level normalization. Calculated in RNA assay. (NormalizeData)
#' @param s.features A vector of features associated with S phase. Calculated in RNA assay. (CellCycleScoring)
#' @param g2m.features A vector of features associated with G2M phase. Calculated in RNA assay. (CellCycleScoring)
#' @param assay which assay to be used for integration. default RNA.
#' @param nfeatures Number of features to return (SelectIntegrationFeatures)
#' @param integration_features if NULL use nfeatures, else use these feature for fastMNN
#' @param remove_ccgenes_by_cor whether to exclude cell cycle-related genes using correlation method.
#' @param cc_cor_th feature genes with correlation coefficient larger than this threshold will be removed.
#' @param mnn_d Number of dimensions to use for dimensionality reduction in multiBatchPCA. (batchelor::fastMNN)
#' @param seed random seed for fastMNN
#' @param skip_tsne you may set TRUE to skip RunTSNE step for large dataset.
#' @param skip_clustering you may set TRUE to skip FindNeighbors and FindClusters steps for large dataset.
#' @param resolution Value of the resolution parameter (FindClusters)
#' @param save_object_prefix Set NULL to skip save files and FindAllMarker steps. Or a character setting the object prefix, e.g. AAA will get AAA_mnn and AAA_degs being returned.
#' @param save_degs_dir {save_object_prefix}_degs.seurat_clusters.{sys.time}.xls will be written to here.
#' @param logfc.threshold Limit testing to genes which show at least X-fold difference (log-scale) between the two groups of cells. (FindAllMarkers)
#' @param min.pct only test genes that are detected in a minimum fraction of min.pct cells in either of the two populations. (FindAllMarkers)
#' @param save_rdata_dir {save_object_prefix}_mnn.seurat.{sys.time}.Rdata will be written to here.
#' @param save_add.sys.time whether to add sys.time to file names.
#' @param ... Extra parameters passed to batchelor::fastMNN.
#'
#' @return seurat object if save_object_prefix is NULL, else saved files.
#' @export
#'
#' @examples
#'
pp_fastMNN <- function(object_list, genes_used = NULL,
                       batch_by = "Batch",
                       scale.factor = 1e5,
                       s.features = cc.genes$s.genes, g2m.features = cc.genes$g2m.gene,
                       assay = c("RNA", "SCT"),
                       nfeatures = 2000,
                       integration_features = NULL,
                       remove_ccgenes_by_cor = T, cc_cor_th = 0.3,
                       mnn_d = 20, seed = 666,
                       skip_tsne = F,
                       skip_clustering = F,
                       resolution = 0.5,
                       save_object_prefix = NULL,
                       save_degs_dir = "tables/",
                       logfc.threshold = log(2), min.pct = 0.25,
                       save_rdata_dir = "seuratData/",
                       save_add.sys.time = F,
                       ...){

  if(is.null(genes_used)){
    genes_used <- Reduce(intersect, lapply(object_list, rownames))
  }

  for(i in 1:length(object_list)){
    object_list[[i]]$Dataset <- paste0("Dataset_", i)
  }
  object_merge <- merge(object_list[[1]], object_list[-1])[genes_used, ]

  DefaultAssay(object_merge) <- "RNA"
  object_merge %<>% NormalizeData(scale.factor = scale.factor) %>%
    CellCycleScoring(s.features = s.features, g2m.features = g2m.features, set.ident = T)

  assay <- match.arg(assay)
  if(assay == "SCT"){
    object_merge %<>% SCTransform(variable.features.n = nfeatures)
  }

  # the following function should use default assay.

  object_merge_list <- SplitObject(object_merge, split.by = batch_by)
  object_merge_features <- SelectIntegrationFeatures(
    object_merge_list,
    nfeatures = nfeatures,
    fvf.nfeatures = nfeatures#, assay = rep("RNA",length(object_merge_list))
    )

  if(!is.null(integration_features)) object_merge_features <- intersect(integration_features, rownames(object_merge))
  ## CC genes
  if(remove_ccgenes_by_cor){
    object_merge_cc_cor <- apply(GetAssayData(object_merge)[object_merge_features,], 1,
                                 function(x){
                                   max(abs(cor(x, object_merge$S.Score)),
                                       abs(cor(x, object_merge$G2M.Score)))
                                 }
    )
    object_merge_features <- setdiff(object_merge_features, names(which(object_merge_cc_cor > cc_cor_th)))
  }


  object_merge_mnn_d <- mnn_d
  set.seed(seed) # seems like the following function produce random result
  object_merge_mnn <- SeuratWrappers::RunFastMNN(
    object_merge_list,
    #assay = "RNA",
    features = object_merge_features,
    d = object_merge_mnn_d,
    ...
  )

  # return variable genes used for MNN
  object_merge_mnn@reductions$mnn@misc <- list(variable_features = object_merge_features)

  object_merge_mnn %<>% RunUMAP(reduction = "mnn", dims = 1:object_merge_mnn_d)
  if(!skip_tsne) object_merge_mnn %<>% RunTSNE(reduction = "mnn", dims = 1:object_merge_mnn_d)

  if(!skip_clustering){
    object_merge_mnn %<>% FindNeighbors(dims = 1:object_merge_mnn_d, reduction = "mnn")
    object_merge_mnn %<>% FindClusters(resolution = resolution)
  }

  if(!is.null(save_object_prefix)){
    time_suffix <- ifelse(save_add.sys.time, base::Sys.time(), "")
    degs_file <- file.path(save_degs_dir, paste0(save_object_prefix, ".degs.seurat_clusters.", time_suffix,".xls"))
    rdata_file <- file.path(save_rdata_dir, paste0(save_object_prefix, "_mnn.seurat.", time_suffix,".Rdata"))

    object_merge_degs <- FindAllMarkers(object_merge_mnn, assay = "RNA",
                                        logfc.threshold = logfc.threshold, min.pct = min.pct, only.pos = T)
    WriteXLS::WriteXLS(object_merge_degs, ExcelFileName = degs_file)

    assign(paste0(save_object_prefix, "_mnn"), object_merge_mnn)
    assign(paste0(save_object_prefix, "_degs"), object_merge_degs)
    save(list = paste0(save_object_prefix, c("_mnn", "_degs")), file = rdata_file)
  }else{
    return(object_merge_mnn)
  }
}


#' @title Scrublet
#' @description See preprint: Scrublet: computational identification of cell doublets in single-cell transcriptomic data
#' Samuel L Wolock, Romain Lopez, Allon M Klein.  bioRxiv 357368; doi: https://doi.org/10.1101/357368
#'
#' see also https://rdrr.io/github/scfurl/m3addon/src/R/scrublet.R
#'
#' @param object the Seurat Object upon which to perform Scrublet, RNA assay count slot will be used.
#' @param return_results_only bool (optional, default False)
#' @param min_counts, int (optional, default=2), See scrublet reference
#' @param min_cells, int (optional, default=3), See scrublet reference
#' @param expected_doublet_rate, float (optional, default=0.06), See scrublet reference - expected_doublet_rate: the
#' fraction of transcriptomes that are doublets, typically 0.05-0.1. Results are not particularly sensitive to this parameter. For this example, the expected doublet rate comes from the Chromium User Guide: https://support.10xgenomics.com/permalink/3vzDu3zQjY0o2AqkkkI4CC
#' @param min_gene_variability_pctl, int (optional, default=85), See scrublet reference
#' @param n_prin_comps, int (optional, default=50), See scrublet reference  (Number of principal components to use)
#' @param sim_doublet_ratio, int (optional, default=2),  the number of doublets to simulate, relative to the number of observed transcriptomes. This should be high enough that all doublet states are well-represented by simulated doublets. Setting it too high is computationally expensive. The default value is 2, though values as low as 0.5 give very similar results for the datasets that have been tested.
#' @param n_neighbors, int (optional) n_neighbors: Number of neighbors used to construct the KNN classifier of observed transcriptomes and simulated doublets. The default value of round(0.5*sqrt(n_cells)) generally works well.
#' Return only a list containing scrublet output
#' @return The input CellDataSet with an additional column added to pData with both the doublet_score output from scrublet,
#' and
#' @importFrom reticulate use_python
#' @importFrom reticulate source_python
#' @export
pp_scrublet <- function (object,
                        return_results_only = FALSE, min_counts=2,
                        min_cells=3, expected_doublet_rate=NULL,
                        min_gene_variability_pctl=85,
                        n_prin_comps=50, sim_doublet_ratio=2, n_neighbors=NULL)
{
  #reticulate::use_python(python_home)
  if(!reticulate::py_available("scrublet")) stop("python module scrublet does not seem to be installed; - try running 'py_config()'")
  reticulate::source_python(file.path(system.file(package = "convgene"),
                                  "scrublet.py"))
  X <- Matrix::t(object@assays$RNA@counts) %>% as("dgTMatrix")
  i <- as.integer(X@i)
  j <- as.integer(X@j)
  val <- X@x
  dim <- as.integer(X@Dim)
  if(is.null(n_neighbors)){
    n_neighbors <- round(0.5*sqrt(nrow(X)))
  }


    # Rates in the 'Chromium Single Cell 3’ Reagent Kits v2 User Guide':
    # Multiplet Rate (%)  # of Cells Loaded   # of Cells Recovered
    # 0.40%   870 500
    # 0.80%   1700    1000
    # 1.60%   3500    2000
    # 2.30%   5300    3000
    # 3.10%   7000    4000
    # 3.90%   8700    5000
    # 4.60%   10500   6000
    # 5.40%   12200   7000
    # 6.10%   14000   8000
    # 6.90%   15700   9000
    # 7.60%   17400   10000
    # from the Chromium User Guide: https://support.10xgenomics.com/permalink/3vzDu3zQjY0o2AqkkkI4CC
    #
    # Rates in the 'Chromium Single Cell 3’ Reagent Kits v3 User Guide':
    # Multiplet Rate (%) # of Cells Loaded # of Cells Recovered
    # ~0.4%	~800	~500
    # ~0.8%	~1,600	~1,000
    # ~1.6%	~3,200	~2,000
    # ~2.3%	~4,800	~3,000
    # ~3.1%	~6,400	~4,000
    # ~3.9%	~8,000	~5,000
    # ~4.6%	~9,600	~6,000
    # ~5.4%	~11,200	~7,000
    # ~6.1%	~12,800	~8,000
    # ~6.9%	~14,400	~9,000
    # ~7.6%	~16,000	~10,000
    # from the Chromium User Guide: https://support.10xgenomics.com/single-cell-gene-expression/overview/doc/user-guide-chromium-single-cell-3-reagent-kits-user-guide-v3-chemistry#header
    #
    # initialize Scrublet object
    # The relevant parameters are:
    #
    # expected_doublet_rate: the expected fraction of transcriptomes that are doublets, typically 0.05-0.1. Results are not particularly sensitive to this parameter. For this example, the expected doublet rate comes from the Chromium User Guide: https://support.10xgenomics.com/permalink/3vzDu3zQjY0o2AqkkkI4CC
    # sim_doublet_ratio: the number of doublets to simulate, relative to the number of observed transcriptomes. This should be high enough that all doublet states are well-represented by simulated doublets. Setting it too high is computationally expensive. The default value is 2, though values as low as 0.5 give very similar results for the datasets that have been tested.
    # n_neighbors: Number of neighbors used to construct the KNN classifier of observed transcriptomes and simulated doublets. The default value of round(0.5*sqrt(n_cells)) generally works well.

  if(is.null(expected_doublet_rate)){
    expected_doublet_rate <- 0.39*nrow(X)/50000
  }

  scrublet_py_args<-c(list(i=i, j=j, val=val, dim=dim,
                           expected_doublet_rate=expected_doublet_rate, min_counts=min_counts,
                           min_cells=min_cells, min_gene_variability_pctl=min_gene_variability_pctl, n_prin_comps=n_prin_comps,
                           sim_doublet_ratio=sim_doublet_ratio, n_neighbors=n_neighbors))
  scrublet_res <- do.call(scrublet_py, scrublet_py_args)
  names(scrublet_res)<-c("doublet_scores", "predicted_doublets")
  if (return_results_only) {
    return(scrublet_res)
  }
  else {
    object[["scrublet_score"]]<-scrublet_res$doublet_scores
    object[["scrublet_predicted"]]<-scrublet_res$predicted_doublets
    object
  }
}


#' A wrapper function to quickly run fastMNN using SeuratWrappers::RunFastMNN
#'
#' Run NormalizeData, CellCycleScoring, SelectIntegrationFeatures, RunFastMNN, RunUMAP/TSNE, FindClusters and FindMarkers.
#' And save object_mnn and object_degs to xls and Rdata files.
#'
#' @param object_list a list of Seurat objects
#' @param genes_used Set NULL to use the intersection of all Seurat objects.
#' @param batch_by Attribute for splitting. Default is "Batch". (SplitObject)
#' @param scale.factor Sets the scale factor for cell-level normalization. (NormalizeData)
#' @param s.features A vector of features associated with S phase (CellCycleScoring)
#' @param g2m.features A vector of features associated with G2M phase (CellCycleScoring)
#' @param nfeatures Number of features to return (SelectIntegrationFeatures)
#' @param do.regress.cc regress out cell cycle scores (ScaleData)
#' @param ndim Number of dimensions to use for dimensionality reduction in multiBatchPCA. (batchelor::fastMNN)
#' @param skip_tsne you may set TRUE to skip RunTSNE step for large dataset.
#' @param resolution Value of the resolution parameter (FindClusters)
#' @param save_object_prefix Set NULL to skip save files and FindAllMarker steps. Or a character setting the object prefix, e.g. AAA will get AAA_mnn and AAA_degs being returned.
#' @param save_degs_dir {save_object_prefix}_degs.seurat_clusters.{sys.time}.xls will be written to here.
#' @param logfc.threshold Limit testing to genes which show at least X-fold difference (log-scale) between the two groups of cells. (FindAllMarkers)
#' @param min.pct only test genes that are detected in a minimum fraction of min.pct cells in either of the two populations. (FindAllMarkers)
#' @param save_rdata_dir {save_object_prefix}_mnn.seurat.{sys.time}.Rdata will be written to here.
#' @param save_add.sys.time whether to add sys.time to file names.
#' @param ... Extra parameters passed to IntegrateData
#'
#' @return seurat object if save_object_prefix is NULL, else saved files.
#' @export
#'
#' @examples
#'
pp_seuratV3Integration <- function(object_list, genes_used = NULL,
                       batch_by = "Batch",
                       scale.factor = 1e5,
                       s.features = cc.genes$s.genes, g2m.features = cc.genes$g2m.gene,
                       nfeatures = 2000, do.regress.cc = T,
                       ndim = 20, skip_tsne = F,
                       resolution = 0.5,
                       save_object_prefix = NULL,
                       save_degs_dir = "tables/",
                       logfc.threshold = log(2), min.pct = 0.25,
                       save_rdata_dir = "seuratData/",
                       save_add.sys.time = F,
                       ...){

  if(is.null(genes_used)){
    genes_used <- Reduce(intersect, lapply(object_list, rownames))
  }

  for(i in 1:length(object_list)){
    object_list[[i]]$Dataset <- paste0("Dataset_", i)
  }
  object_merge <- merge(object_list[[1]], object_list[-1])[genes_used, ]

  DefaultAssay(object_merge) <- "RNA"

  object_merge %<>% NormalizeData(scale.factor = scale.factor) %>%
    CellCycleScoring(s.features = s.features, g2m.features = g2m.features, set.ident = T)

  object_merge_list <- SplitObject(object_merge, split.by = batch_by)
  for (i in 1:length(object_merge_list)) {
    object_merge_list[[i]] <- FindVariableFeatures(
      object_merge_list[[i]],
      nfeatures = nfeatures, verbose = FALSE)
  }

  object_merge_anchors <- FindIntegrationAnchors(object.list = object_merge_list)
  object_merge_integrated <- IntegrateData(anchorset = object_merge_anchors, ...)

  vars.to.regress <- if(do.regress.cc) c("S.Score", "G2M.Score") else NULL

  object_merge_integrated <- ScaleData(object_merge_integrated, verbose = FALSE,
                                       vars.to.regress = vars.to.regress)
  object_merge_integrated %<>% RunPCA()

  object_merge_integrated %<>% RunUMAP(reduction = "pca", dims = 1:ndim)
  if(!skip_tsne) object_merge_integrated %<>% RunTSNE(reduction = "pca", dims = 1:ndim)

  object_merge_integrated %<>% FindNeighbors(dims = 1:ndim, reduction = "pca")
  object_merge_integrated %<>% FindClusters(resolution = resolution)

  if(!is.null(save_object_prefix)){
    time_suffix <- ifelse(save_add.sys.time, base::Sys.time(), "")
    degs_file <- file.path(save_degs_dir, paste0(save_object_prefix, ".degs.seurat_clusters.", time_suffix,".xls"))
    rdata_file <- file.path(save_rdata_dir, paste0(save_object_prefix, "_integrated.seurat.", time_suffix,".Rdata"))

    object_merge_degs <- FindAllMarkers(object_merge_integrated, assay = "RNA",
                                        logfc.threshold = logfc.threshold, min.pct = min.pct, only.pos = T)
    WriteXLS::WriteXLS(object_merge_degs, ExcelFileName = degs_file)

    assign(paste0(save_object_prefix, "_integrated"), object_merge_integrated)
    assign(paste0(save_object_prefix, "_degs"), object_merge_degs)
    save(list = paste0(save_object_prefix, c("_integrated", "_degs")), file = rdata_file)
  }else{
    return(object_merge_integrated)
  }
}


#' transform reduction coordinates
#'
#' @param object seurat3 object
#' @param reduction umap or tsne or something
#' @param transform_matrix 3 x 3 matrix derived from crosslink::transform_matrix_affine
#'
#' @return seurat3 object
#' @export
#'
#' @examples
#'
pp_transform2dDim <- function(object, reduction = "umap", transform_matrix = crosslink::transform_matrix_affine(type = "reflect", theta = 0)){
  if(reduction %in% Reductions(object)){
    coln <- colnames(object@reductions[[reduction]]@cell.embeddings)
    object@reductions[[reduction]]@cell.embeddings %<>%
      transform_by_matrix(
        matrix = transform_matrix
      )
    colnames(object@reductions[[reduction]]@cell.embeddings) <- coln
    return(object)
  }else{
    stop(reduction,"does not exist!")
  }
}


#' Add Mitochondrial genes ratio
#'
#' @param object seurat object
#' @param nCount colname of meta.data for UMI count
#' @param mito_genes genes to be used as Mitochondrial genes. default: `grepl("^mt-", rownames(object), ignore.case = T)`
#'
#' @return updated seurat object
#' @export
#'
#' @examples
#'
pp_addMitoRatio <- function(object, nCount = "nCount_RNA", mito_genes = NULL){
  if(is.null(mito_genes)) mito_genes <- grepl("^mt-", rownames(object), ignore.case = T)
  object$rMT_RNA <-
    Matrix::colSums(GetAssayData(object, slot = "counts")[mito_genes,])/object[[nCount]]
  return(object)
}
